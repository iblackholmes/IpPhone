package ipPhone_client;

import java.io.IOException;
import java.io.ObjectOutputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Scanner;

import javax.sound.sampled.LineUnavailableException;

import ipPhone_util.*;

public class IpPhoneClient{
	private Scanner sc = new Scanner(System.in);
	private int SIZE = 50 * 1024;// max_size of buffer
	
	private String clientInetAddress;// InetAddress of client
	private String serverInetAddress;// InetAddress of server
	private Socket socket;// socket for dialing server
	private ObjectOutputStream OOS;// send client connecting status to server
	
	private int clientID;// client ID, generated by time-stamp
	private ArrayList<Message> messages;// list of messages for sending to server
	
	public IpPhoneClient(long timeStamp) {
		this.clientID = (int)timeStamp%1597;
		this.initClient();
		this.startClient();
	}
	
	public int getClientID() {return this.clientID;}

	/** start client **/
	public void startClient() {
		this.connectToServer();// client start connecting to server
		this.startMicroPhone();// start microphone
		this.sendData();// send data to server
		this.receiveData();// receive data from server
	}
	
	/** initialize client **/
	private void initClient() {
		System.out.println("please input client InetAddress:");
		this.clientInetAddress = sc.nextLine();
		System.out.println("please input server InetAddress:");
		this.serverInetAddress = sc.nextLine();
		this.messages = new ArrayList<Message>();
	}
	
	/** add messages to queue for sending **/
	public void addToMssageQueue(Message message) {
		this.messages.add(message);
	}
	
	/** client start connecting to server **/
	private void connectToServer() {
		int port_TCP = 6584;// port_TCP for dialing
		try {
			// client begin connecting with server by TCP
			this.socket = new Socket(this.serverInetAddress, port_TCP);
			System.out.println("client(" + this.clientID + ") connected to server");
			
			// send client information to server
			OOS = new ObjectOutputStream(socket.getOutputStream());
			OOS.writeObject(new ClientDataPacket(new InetSocketAddress(InetAddress.getByName("localhost"),this.clientID), true));
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		// wait for END signal from console
		new Thread() {
			@Override
			public void run() {
				try {
					System.out.println("input '1' to end client:");
					
					int inputNum = sc.nextInt();
					if(inputNum == 1) {
						OOS.writeObject(new ClientDataPacket(new InetSocketAddress(InetAddress.getByName("localhost"),clientID), false));
						
						// close connection
						sc.close();
						OOS.close();
						socket.close();
						System.out.println("client(" + clientID + ") end connection");
						System.exit(0);
					}
				}catch(Exception e) {
					e.printStackTrace();
				}
			}
		}.start();
	}
	
	/** start microphone **/
	private void startMicroPhone() {
		try {
			new MicThread(this).start();
		} catch (LineUnavailableException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println("mic unavailable ");
		}
	}
	
	/** receive data from server **/
	private void receiveData() {
		byte[] receiveBuf = new byte[SIZE];// received data
		AudioChannel channel = new AudioChannel();// channel for playing sound
		channel.start();
		
		System.out.println("client is ready for receiving data");
		try {
			DatagramPacket receiveDpk = new DatagramPacket(receiveBuf, receiveBuf.length);
			DatagramSocket receiveDsk = new DatagramSocket(new InetSocketAddress(InetAddress.getByName(clientInetAddress),this.clientID));
			
			while(socket.isConnected()) {
				// get messages from server
				receiveDsk.receive(receiveDpk);
				Message message = (Message)DataTransfer.byteArrayToSerializableObject(receiveDpk.getData());
				if(message == null) {
					System.out.println("client(" + this.clientID + ") receive a null object");
					continue;
				}
				
				// add message to channel
				channel.addToQueue(message);
			}
			receiveDsk.close();
			OOS.close();
		}catch(Exception e) {
			e.printStackTrace();
		}
	}
	
	/** send data to server **/
	private void sendData() {
		System.out.println("client is ready for sending data");
		new dataSender().start();
	}
	
	/** data sender thread **/
	private class dataSender extends Thread {
		private Message getMessageFromQueue() {
			while(true) {
				if(messages.isEmpty()) {
					try {
						sleep(10);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					continue;
				}else {
					Message m = messages.get(0);
					messages.remove(m);
					return m;
				}	
			}
		}
		
		@Override
		public void run() {
			int port_UDP = 7135;// port_UDP for send data
			byte[] sendBuf = new byte[SIZE];// send data
			
			try {
				DatagramPacket sendDpk = new DatagramPacket(
						sendBuf, 
						sendBuf.length,
						new InetSocketAddress(InetAddress.getByName(serverInetAddress), 
						port_UDP));
				@SuppressWarnings("resource")
				DatagramSocket sendDsk = new DatagramSocket();
				while(true) {
					sendBuf = DataTransfer.serializableObjectToByteArray(this.getMessageFromQueue());

					// send data to server
					sendDpk.setData(sendBuf, 0, sendBuf.length);
					sendDsk.send(sendDpk);
				}
			}catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				System.out.println("client(" + clientID + ") send data error");
			}
		}
	}

	public static void main(String[] args) {
		try {
			new IpPhoneClient(System.currentTimeMillis());
		}catch(Exception e) {
			e.printStackTrace();
			System.out.println("Create client thread fail");
		}
	}
}
